import math
import argparse

from nltk.grammar import Nonterminal, PCFG
from pcfg_generate import *

parser = argparse.ArgumentParser(description='alfa value')
parser.add_argument(
    '--alfa',
    '-a',
    dest='alfa',
    action='store',
    required=True,
    help='alfa'
)

args = parser.parse_args()

alfa = args.alfa
beta = math.pow(2,(-1)*float(alfa))
print ("alfa: " + str(alfa))
print ("beta: " + str(beta))
#alfa=1; beta=0.5
#	P(CW2D)=beta/20 = 0.025
#	P(AW2B)=(1-beta)/20 = 0.025

#alfa=1.1; beta= 0,466516496
#	P(CW2D)=beta/20 = 0,023325825 = 0.023
#	P(AW2B)=(1-beta)/20 = 0,026674175 = 0.027

#alfa=1.3; beta= 0,406126198
#	P(CW2D)=beta/20 = 0,02030631 = 0.02
#	P(AW2B)=(1-beta)/20 = 0,02969369 = 0.03

#alfa=1.5; beta= 0,353553391
#	P(CW2D)=beta/20 = 0,01767767 = 0.0177
#	P(AW2B)=(1-beta)/20 = 0,03232233 = 0.0323

#alfa=1.7; beta= 0,307786103
#	P(CW2D)=beta/20 = 0,015389305 = 0.0154
#	P(AW2B)=(1-beta)/20 = 0,034610695 = 0.0346

#alfa=1.9; beta= 0,267943366
#	P(CW2D)=beta/20 = 0,013397168 = 0.0134
#	P(AW2B)=(1-beta)/20 = 0,036602832 = 0.0366

#alfa=2; beta=0.25
#	P(CW2D)=beta/20 = 0.0125
#	P(AW2B)=(1-beta)/20 = 0.0375

beta_20 = round(beta/20,4) #se redondea a cuatro decimales
print ("beta_20: " + str(beta_20))
#beta_20 y compl_beta_20 deben sumar siempre 0.05
compl_beta_20 = 0.05 - beta_20
print ("compl_beta_20: " + str(compl_beta_20))

grammar = """
    S -> A V1 B [0.5] | C W1 D [0.45] | C W2 D [""" + str(beta_20) + """] | A W2 B [""" + str(compl_beta_20) + """]
    A -> 'a0' [0.1] | 'a1' [0.1] | 'a2' [0.1] | 'a3' [0.1] | 'a4' [0.1] | 'a5' [0.1] | 'a6' [0.1] | 'a7' [0.1] | 'a8' [0.1] | 'a9' [0.1]
    B -> 'b0' [0.1] | 'b1' [0.1] | 'b2' [0.1] | 'b3' [0.1] | 'b4' [0.1] | 'b5' [0.1] | 'b6' [0.1] | 'b7' [0.1] | 'b8' [0.1] | 'b9' [0.1]
    C -> 'c0' [0.1] | 'c1' [0.1] | 'c2' [0.1] | 'c3' [0.1] | 'c4' [0.1] | 'c5' [0.1] | 'c6' [0.1] | 'c7' [0.1] | 'c8' [0.1] | 'c9' [0.1]
    D -> 'd0' [0.1] | 'd1' [0.1] | 'd2' [0.1] | 'd3' [0.1] | 'd4' [0.1] | 'd5' [0.1] | 'd6' [0.1] | 'd7' [0.1] | 'd8' [0.1] | 'd9' [0.1]    
    V1 -> 'v0' [0.02] | 'v1' [0.02] | 'v2' [0.02] | 'v3' [0.02] | 'v4' [0.02] | 'v5' [0.02] | 'v6' [0.02] | 'v7' [0.02] | 'v8' [0.02] | 'v9' [0.02] | 'v10' [0.02] | 'v11' [0.02] | 'v12' [0.02] | 'v13' [0.02] | 'v14' [0.02] | 'v15' [0.02] | 'v16' [0.02] | 'v17' [0.02] | 'v18' [0.02] | 'v19' [0.02] | 'v20' [0.02] | 'v21' [0.02] | 'v22' [0.02] | 'v23' [0.02] | 'v24' [0.02] | 'v25' [0.02] | 'v26' [0.02] | 'v27' [0.02] | 'v28' [0.02] | 'v29' [0.02] | 'v30' [0.02] | 'v31' [0.02] | 'v32' [0.02] | 'v33' [0.02] | 'v34' [0.02] | 'v35' [0.02] | 'v36' [0.02] | 'v37' [0.02] | 'v38' [0.02] | 'v39' [0.02] | 'v40' [0.02] | 'v41' [0.02] | 'v42' [0.02] | 'v43' [0.02] | 'v44' [0.02] | 'v45' [0.02] | 'v46' [0.02] | 'v47' [0.02] | 'v48' [0.02] | 'v49' [0.02]
    W1 ->'w5' [0.0232] | 'w6' [0.0222] | 'w7' [0.0222] | 'w8' [0.0222] | 'w9' [0.0222] | 'w10' [0.0222] | 'w11' [0.0222] | 'w12' [0.0222] | 'w13' [0.0222] | 'w14' [0.0222] | 'w15' [0.0222] | 'w16' [0.0222] | 'w17' [0.0222] | 'w18' [0.0222] | 'w19' [0.0222] | 'w20' [0.0222] | 'w21' [0.0222] | 'w22' [0.0222] | 'w23' [0.0222] | 'w24' [0.0222] | 'w25' [0.0222] | 'w26' [0.0222] | 'w27' [0.0222] | 'w28' [0.0222] | 'w29' [0.0222] | 'w30' [0.0222] | 'w31' [0.0222] | 'w32' [0.0222] | 'w33' [0.0222] | 'w34' [0.0222] | 'w35' [0.0222] | 'w36' [0.0222] | 'w37' [0.0222] | 'w38' [0.0222] | 'w39' [0.0222] | 'w40' [0.0222] | 'w41' [0.0222] | 'w42' [0.0222] | 'w43' [0.0222] | 'w44' [0.0222] | 'w45' [0.0222] | 'w46' [0.0222] | 'w47' [0.0222] | 'w48' [0.0222] | 'w49' [0.0222] 
    W2 -> 'w0' [0.2] | 'w1' [0.2] | 'w2' [0.2] | 'w3' [0.2] | 'w4' [0.2] 

"""
print(grammar)

ambiguity = PCFG.fromstring(grammar)
print(ambiguity)


archivo_destino = 'ambiguity_alfa_' + str(alfa) + '.txt'
with open(archivo_destino, 'w') as f:
    for sentence in pcfg_generate(ambiguity, n=100000, depth=100):
       f.write(' '.join(sentence) +'\n')



